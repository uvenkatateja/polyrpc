//! TypeScript Definition Generator
//!
//! Converts parsed Python types into TypeScript definitions.

use crate::parser::{ApiRoute, ExtractedTypes, PyType, PydanticModel};
use anyhow::{Context, Result};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// Generate TypeScript definitions from extracted Python types
pub fn generate_definitions(types: &ExtractedTypes) -> String {
    let mut output = String::new();
    
    // Header
    output.push_str("// Auto-generated by PolyRPC - DO NOT EDIT\n");
    output.push_str("// Generated from Python source files\n\n");
    
    // Generate interfaces for models
    output.push_str("// ============ Models ============\n\n");
    
    // Sort models for deterministic output
    let mut models: Vec<_> = types.models.values().collect();
    models.sort_by(|a, b| a.name.cmp(&b.name));
    
    for model in models {
        output.push_str(&generate_interface(model));
        output.push('\n');
    }
    
    // Generate API types
    if !types.routes.is_empty() {
        output.push_str("// ============ API Routes ============\n\n");
        output.push_str(&generate_api_types(&types.routes, &types.models));
    }
    
    // Generate the main namespace
    output.push_str(&generate_namespace(types));
    
    output
}

/// Generate a TypeScript interface from a Pydantic model
fn generate_interface(model: &PydanticModel) -> String {
    let mut output = String::new();
    
    // Add docstring as JSDoc
    if let Some(doc) = &model.docstring {
        output.push_str("/**\n");
        for line in doc.lines() {
            output.push_str(&format!(" * {}\n", line.trim()));
        }
        output.push_str(" */\n");
    }
    
    output.push_str(&format!("export interface {} {{\n", model.name));
    
    for field in &model.fields {
        // Add field description as JSDoc if present
        if let Some(desc) = &field.description {
            output.push_str(&format!("  /** {} */\n", desc));
        }
        
        let ts_type = py_type_to_ts(&field.py_type);
        let optional_marker = if field.optional { "?" } else { "" };
        
        output.push_str(&format!("  {}{}: {};\n", field.name, optional_marker, ts_type));
    }
    
    output.push_str("}\n");
    output
}

/// Convert a Python type to TypeScript type string
fn py_type_to_ts(py_type: &PyType) -> String {
    match py_type {
        PyType::String => "string".to_string(),
        PyType::Int | PyType::Float => "number".to_string(),
        PyType::Bool => "boolean".to_string(),
        PyType::None => "null".to_string(),
        PyType::Any => "unknown".to_string(),
        PyType::List(inner) => format!("{}[]", py_type_to_ts(inner)),
        PyType::Dict(key, value) => {
            format!("Record<{}, {}>", py_type_to_ts(key), py_type_to_ts(value))
        }
        PyType::Optional(inner) => format!("{} | null", py_type_to_ts(inner)),
        PyType::Union(types) => {
            let ts_types: Vec<String> = types.iter().map(py_type_to_ts).collect();
            ts_types.join(" | ")
        }
        PyType::Literal(values) => {
            let quoted: Vec<String> = values.iter().map(|v| format!("\"{}\"", v)).collect();
            quoted.join(" | ")
        }
        PyType::Reference(name) => name.clone(),
        PyType::Unknown(_name) => {
            // Log warning in debug mode
            #[cfg(debug_assertions)]
            eprintln!("Warning: Unknown type '{}' mapped to 'unknown'", name);
            "unknown".to_string()
        }
    }
}

/// Generate API route types
fn generate_api_types(routes: &[ApiRoute], _models: &HashMap<String, PydanticModel>) -> String {
    let mut output = String::new();
    
    // Group routes by path prefix for organization
    output.push_str("export interface ApiRoutes {\n");
    
    for route in routes {
        let method_lower = route.method.to_lowercase();
        let path_key = route.path.replace('/', "_").replace('{', "").replace('}', "");
        let _path_key = if path_key.starts_with('_') {
            &path_key[1..]
        } else {
            &path_key
        };
        
        // Input type (path params + query params + body)
        let input_type = generate_route_input_type(&route);
        
        // Output type
        let output_type = route
            .response_model
            .as_ref()
            .map(|m| m.clone())
            .unwrap_or_else(|| "void".to_string());
        
        output.push_str(&format!(
            "  '{}:{}': {{ input: {}; output: {} }};\n",
            method_lower, route.path, input_type, output_type
        ));
    }
    
    output.push_str("}\n\n");
    output
}

/// Generate input type for a route
fn generate_route_input_type(route: &ApiRoute) -> String {
    let mut parts = Vec::new();
    
    // Path parameters
    if !route.path_params.is_empty() {
        let params: Vec<String> = route
            .path_params
            .iter()
            .map(|p| format!("{}: string | number", p))
            .collect();
        parts.push(format!("{{ {} }}", params.join("; ")));
    }
    
    // Request body
    if let Some(model) = &route.request_model {
        parts.push(model.clone());
    }
    
    if parts.is_empty() {
        "void".to_string()
    } else if parts.len() == 1 {
        parts[0].clone()
    } else {
        // Merge types
        parts.join(" & ")
    }
}

/// Generate the main PolyRPC namespace with route helpers
fn generate_namespace(types: &ExtractedTypes) -> String {
    let mut output = String::new();
    
    output.push_str("// ============ PolyRPC Client Types ============\n\n");
    
    // Generate route tree type
    output.push_str("export interface PolyRPCRoutes {\n");
    
    // Group routes by first path segment
    let mut route_groups: HashMap<String, Vec<&ApiRoute>> = HashMap::new();
    for route in &types.routes {
        let first_segment = route
            .path
            .trim_start_matches('/')
            .split('/')
            .next()
            .unwrap_or("root");
        route_groups
            .entry(first_segment.to_string())
            .or_default()
            .push(route);
    }
    
    for (group, routes) in &route_groups {
        output.push_str(&format!("  {}: {{\n", group));
        
        for route in routes {
            let _method_lower = route.method.to_lowercase();
            let response_type = route
                .response_model
                .as_ref()
                .cloned()
                .unwrap_or_else(|| "void".to_string());
            
            let input_type = generate_route_input_type(route);
            
            output.push_str(&format!(
                "    {}: {{\n",
                route.function_name
            ));
            output.push_str(&format!(
                "      query: (input: {}) => Promise<{}>;\n",
                input_type, response_type
            ));
            output.push_str(&format!(
                "      mutate: (input: {}) => Promise<{}>;\n",
                input_type, response_type
            ));
            output.push_str("    };\n");
        }
        
        output.push_str("  };\n");
    }
    
    output.push_str("}\n\n");
    
    // Export the main client type
    output.push_str("declare const py: PolyRPCRoutes;\n");
    output.push_str("export { py };\n");
    
    output
}

/// Write definitions to file
pub fn write_definitions(path: &Path, types: &ExtractedTypes) -> Result<()> {
    let content = generate_definitions(types);
    
    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory: {}", parent.display()))?;
    }
    
    fs::write(path, content)
        .with_context(|| format!("Failed to write to {}", path.display()))?;
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_py_type_to_ts() {
        assert_eq!(py_type_to_ts(&PyType::String), "string");
        assert_eq!(py_type_to_ts(&PyType::Int), "number");
        assert_eq!(
            py_type_to_ts(&PyType::List(Box::new(PyType::String))),
            "string[]"
        );
        assert_eq!(
            py_type_to_ts(&PyType::Optional(Box::new(PyType::Int))),
            "number | null"
        );
    }

    #[test]
    fn test_generate_interface() {
        let model = PydanticModel {
            name: "User".to_string(),
            fields: vec![
                ModelField {
                    name: "name".to_string(),
                    py_type: PyType::String,
                    optional: false,
                    default: None,
                    description: None,
                },
                ModelField {
                    name: "age".to_string(),
                    py_type: PyType::Int,
                    optional: true,
                    default: Some("None".to_string()),
                    description: None,
                },
            ],
            docstring: Some("A user model".to_string()),
        };

        let output = generate_interface(&model);
        assert!(output.contains("export interface User"));
        assert!(output.contains("name: string;"));
        assert!(output.contains("age?: number;"));
    }
}
